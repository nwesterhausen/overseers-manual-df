// File generated by specta. Do not edit!
//
/// lib/overseers_manual_df

/**
 * Options for searching for objects in the game.
 */
export type SearchOptions = {
  limit: string;
  page: string;
  objectTypes: ObjectType[];
  query: string;
  locations: RawModuleLocation[];
  biomes: Biome[];
  modules: string[];
  onlyEggLayers: boolean;
  showDoesNotExist: boolean;
};
/**
 * A summary of the parsing process.
 */
export type Summary = {
  totalRaws: string;
  counts: [ObjectType, string][];
  locationTotals: [RawModuleLocation, string][];
  parsingDuration: string;
  saveToStoreDuration: string;
  filteringDuration: string;
  objectsAllowed: ObjectType[];
  locations: RawModuleLocation[];
};
/**
 * Options for getting graphics for an object.
 */
export type GraphicsOptions = { identifier: string; allGraphics: boolean };
/**
 * Graphics search results
 */
export type GraphicsResults = {
  matchingGraphics: Graphic[] | null;
  tilePages: TilePage[];
};
/**
 * Specific storage for graphics and tile pages.
 *
 * This is separate from the `Storage` struct because it reduces the locks on
 * the `Storage` struct. We don't need to lock the `Storage` struct when we're
 * just looking for graphics or tile pages.
 *
 * The `graphics_store` and `tile_page_store` are used to store the graphics
 * and tile pages parsed from the raws. This is done so that we don't have to
 * parse the raws every time we want to get a graphic or tile page.
 */
export type GraphicStorage = {
  graphics_store: { [key: string]: Graphic[] };
  tile_page_store: { [key: string]: TilePage };
};
/**
 * Storage for module info files.
 *
 * This is separate from the `Storage` struct because it reduces the locks on
 * the `Storage` struct. We don't need to lock the `Storage` struct when we're
 * just looking for module info files.
 */
export type ModuleInfoStorage = { module_info_store: InfoFile[] };
/**
 * Information about the build, including version, Rust version, optimization level, debug status, dependencies, build time, and git commit hash.
 */
export type Info = {
  version: string;
  rustVersion: string;
  optimizationLevel: string;
  inDebug: boolean;
  dependencies: [string, string][];
  buildTime: string;
  gitCommitHash: string;
};
/**
 * Function: `parse_all_raws_info`
 *
 * Tracked data is the duration of the event and the total number of files parsed, which
 * can allow for some interesting analysis.
 */
export type ParseAllRawsInfo = { duration: string; total_files: string };
/**
 * Function: `parse_and_store_raws`
 *
 * Tracked data is the duration of the event, the total number of files parsed, the duration
 * of storing the files, the total time elapsed, the types of raws parsed, and the locations
 * parsed from.
 *
 * This function on the backend is responsible for parsing the raws and storing them in memory.
 * The instructions for what raws to parse and where to parse them from are provided by the
 * frontend.
 */
export type ParseAndStoreRaws = {
  total_raws_parsed: string;
  elapsed_time: string;
  parsed_raw_types: string;
  parsed_raw_locations: string;
};
/**
 * Update Skipped
 *
 * Tracked data is whether the update is skipped by the end user, and the versions involved.
 */
export type SkipUpdate = { current_version: string; to_version: string };
/**
 * Apply Update
 *
 * Tracked data is the versions involved.
 */
export type ApplyUpdate = { to_version: string };
/**
 * App Launch
 *
 * No data is collected, just the event.
 */
export type AppStarted<> = null;
/**
 * App Exit
 *
 * No data is collected, just the event.
 */
export type AppExited<> = null;
/**
 * The object types that can be parsed by the parser.
 */
export type ObjectType =
  | "Creature"
  | "Inorganic"
  | "Plant"
  | "Item"
  | "ItemAmmo"
  | "ItemArmor"
  | "ItemFood"
  | "ItemGloves"
  | "ItemHelm"
  | "ItemInstrument"
  | "ItemPants"
  | "ItemShield"
  | "ItemShoes"
  | "ItemSiegeAmmo"
  | "ItemTool"
  | "ItemToy"
  | "ItemTrapComponent"
  | "ItemWeapon"
  | "Building"
  | "BuildingWorkshop"
  | "BuildingFurnace"
  | "Reaction"
  | "Graphics"
  | "MaterialTemplate"
  | "BodyDetailPlan"
  | "Body"
  | "Entity"
  | "Language"
  | "Translation"
  | "TissueTemplate"
  | "CreatureVariation"
  | "TextSet"
  | "TilePage"
  | "DescriptorColor"
  | "DescriptorPattern"
  | "DescriptorShape"
  | "Palette"
  | "Music"
  | "Sound"
  | "Interaction"
  | "Unknown"
  | "SelectCreature"
  | "CreatureCaste";
/**
 * # Parsing Options
 *
 * Specify what to parse and where to parse it from.
 *
 * ## Parsing `info.txt` vs the raw files
 *
 * There are two main parsing functions: `parse` and `parse_module_info_files`.
 *
 * Both use the same options struct, but they use it in different ways.
 *
 * When calling `parse`, the `ParserOptions` struct is used to specify what raws to parse and where to parse them from.
 * Any specified `raw_modules_to_parse` will not be parsed in the `parse` function, and the only items parsed in the
 * `parse_module_info_files` function are the `module_info_files_to_parse`.
 *
 * ## Example
 *
 * ```rust
 * use std::path::PathBuf;
 * use dfraw_json_parser::{ParserOptions, RawObject, ObjectType, RawModuleLocation};
 *
 * let mut options = ParserOptions::new("path/to/dwarf_fortress");
 * options.add_location_to_parse(RawModuleLocation::Vanilla);
 * // Clear the default object types
 * options.set_object_types_to_parse(vec![]);
 * // Add back in the ones we want
 * options.add_object_type_to_parse(ObjectType::Creature);
 * options.add_object_type_to_parse(ObjectType::CreatureVariation);
 * // Include the metadata with the parsed raws
 * options.attach_metadata_to_raws();
 *
 * // Parse the raws and info.txt files (not parsing here because the path is invalid)
 * // let parsed_raws = dfraw_json_parser::parse(&options);
 * ```
 *
 */
export type ParserOptions = {
  attachMetadataToRaws: boolean;
  skipApplyCopyTagsFrom: boolean;
  skipApplyCreatureVariations: boolean;
  objectTypesToParse: ObjectType[];
  locationsToParse: RawModuleLocation[];
  dwarfFortressDirectory: string;
  legendsExportsToParse: string[];
  rawFilesToParse: string[];
  rawModulesToParse: string[];
  moduleInfoFilesToParse: string[];
  logSummary: boolean;
};
/**
 * A struct representing a color in the format "foreground:background:brightness".
 */
export type Color = {
  foreground: number;
  background: number;
  brightness: number;
};
/**
 * Represents the `info.txt` file for a raw module
 */
export type InfoFile = {
  identifier: string;
  objectId: string;
  location: RawModuleLocation;
  parentDirectory: string;
  numericVersion: number;
  displayedVersion: string;
  earliestCompatibleNumericVersion: number;
  earliestCompatibleDisplayedVersion: string;
  author: string;
  name: string;
  description: string;
  requiresIds: string[] | null;
  conflictsWithIds: string[] | null;
  requiresIdsBefore: string[] | null;
  requiresIdsAfter: string[] | null;
  steamData: SteamData | null;
};
/**
 * The `RawMetadata` struct represents metadata about a raw module in Rust, including its name,
 * version, file path, identifier, object type, module location, and visibility status.
 *
 * Properties:
 *
 * * `module_name`: The name of the raw module the raw is from.
 * * `module_version`: The version of the raw module the raw is from.
 * * `raw_file_path`: The `raw_file_path` property is a string that represents the path to the file
 * containing the raw data. It specifies the location of the file on the file system.
 * * `raw_identifier`: The raw identifier is a unique identifier for the raw data. It is typically
 * found at the top of the raw text file and is used to identify and reference the specific raw data.
 * * `object_type`: The `object_type` property represents the type of the raw data. It could be a
 * creature, plant, or any other type specified in the raw text file.
 * * `raw_module_location`: The `raw_module_location` property represents the location of the owning
 * raw module. It can have one of the following values:
 *
 * - `RawModuleLocation::InstalledMods`: The raw module is located in the `installed_mods` folder.
 * - `RawModuleLocation::Mods`: The raw module is located in the `mods` folder.
 * - `RawModuleLocation::Vanilla`: The raw module is located in the `vanilla` folder.
 *
 * * `hidden`: The `hidden` property is a boolean value that indicates whether the raw metadata should
 * be hidden or not when exporting. By default, it is set to `true`, meaning that the raw metadata will
 * be hidden unless specified in the `ParsingOptions` struct.
 */
export type Metadata = {
  moduleObjectId: string;
  moduleName: string;
  moduleVersion: string;
  rawFilePath: string;
  rawIdentifier: string;
  objectType: ObjectType;
  rawModuleLocation: RawModuleLocation;
};
/**
 * Raws are part of modules since 50.xx. Raw modules are loaded from 3 common locations:
 * `{df_directory}/data/vanilla`, `{df_directory}/mods`, and `{df_directory/data/installed_mods}`
 */
export type RawModuleLocation =
  | "InstalledMods"
  | "Mods"
  | "Vanilla"
  | "Unknown"
  | "LegendsExport";
/**
 * The additional data specific to the steam workshop
 */
export type SteamData = {
  title: string | null;
  description: string | null;
  tags: string[] | null;
  keyValueTags: string[] | null;
  metadata: string[] | null;
  changelog: string | null;
  fileId: string;
};
/**
 * An enum representing a biome.
 */
export type Biome =
  | "Mountain"
  | "Mountains"
  | "Glacier"
  | "Tundra"
  | "SwampTemperateFreshwater"
  | "SwampTemperateSaltwater"
  | "MarshTemperateFreshwater"
  | "MarshTemperateSaltwater"
  | "SwampTropicalFreshwater"
  | "SwampTropicalSaltwater"
  | "SwampMangrove"
  | "MarshTropicalFreshwater"
  | "MarshTropicalSaltwater"
  | "ForestTaiga"
  | "Taiga"
  | "ForestTemperateConifer"
  | "ForestTemperateBroadleaf"
  | "ForestTropicalConifer"
  | "ForestTropicalDryBroadleaf"
  | "ForestTropicalMoistBroadleaf"
  | "GrasslandTemperate"
  | "SavannaTemperate"
  | "ShrublandTemperate"
  | "GrasslandTropical"
  | "SavannaTropical"
  | "ShrublandTropical"
  | "DesertBadland"
  | "DesertRock"
  | "DesertSand"
  | "OceanTropical"
  | "OceanTemperate"
  | "OceanArctic"
  | "PoolTemperateFreshwater"
  | "PoolTemperateBrackishwater"
  | "PoolTemperateSaltwater"
  | "PoolTropicalFreshwater"
  | "PoolTropicalBrackishwater"
  | "PoolTropicalSaltwater"
  | "LakeTemperateFreshwater"
  | "LakeTemperateBrackishwater"
  | "LakeTemperateSaltwater"
  | "LakeTropicalFreshwater"
  | "LakeTropicalBrackishwater"
  | "LakeTropicalSaltwater"
  | "RiverTemperateFreshwater"
  | "RiverTemperateBrackishwater"
  | "RiverTemperateSaltwater"
  | "RiverTropicalFreshwater"
  | "RiverTropicalBrackishwater"
  | "RiverTropicalSaltwater"
  | "SubterraneanWater"
  | "SubterraneanChasm"
  | "SubterraneanLava"
  | "AllMain"
  | "AnyLand"
  | "AnyOcean"
  | "AnyLake"
  | "AnyTemperateLake"
  | "AnyTropicalLake"
  | "AnyRiver"
  | "AnyTemperateRiver"
  | "AnyTropicalRiver"
  | "AnyPool"
  | "NotFreezing"
  | "AnyTemperate"
  | "AnyTropical"
  | "AnyForest"
  | "AnyShrubland"
  | "AnyGrassland"
  | "AnySavanna"
  | "AnyTemperateForest"
  | "AnyTropicalForest"
  | "AnyTemperateBroadleaf"
  | "AnyTropicalBroadleaf"
  | "AnyWetland"
  | "AnyTemperateWetland"
  | "AnyTropicalWetland"
  | "AnyTropicalMarsh"
  | "AnyTemperateMarsh"
  | "AnyTropicalSwamp"
  | "AnyTemperateSwamp"
  | "AnyDesert"
  | "Unknown";
/**
 * A struct representing a Graphic object.
 */
export type Graphic = {
  metadata: Metadata | null;
  identifier: string;
  objectId: string;
  casteIdentifier: string | null;
  kind: GraphicType;
  sprites: SpriteGraphic[] | null;
  layers: [string, SpriteLayer[]][] | null;
  growths: [string, SpriteGraphic[]][] | null;
  customExtensions: CustomGraphicExtension[] | null;
  tags: string[] | null;
};
/**
 * A struct representing a `TilePage` object.
 */
export type TilePage = {
  metadata: Metadata | null;
  identifier: string;
  objectId: string;
  file: string;
  tileDim: Dimensions;
  pageDim: Dimensions;
};
/**
 * The graphic type of the tile
 */
export type GraphicType =
  | "creature"
  | "creatureCaste"
  | "statueCreature"
  | "statueCreatureCaste"
  | "statuesSurfaceGiant"
  | "tile"
  | "empty"
  | "plant"
  | "unknown"
  | "template"
  | "soilBackground"
  | "grass1"
  | "grass2"
  | "grass3"
  | "grass4"
  | "customEdging"
  | "customRamp"
  | "customEdgeW"
  | "customEdgeE"
  | "customEdgeN"
  | "customEdgeS"
  | "customEdgeNW"
  | "customEdgeNE"
  | "customEdgeSW"
  | "customEdgeSE"
  | "customWorkshop"
  | "listIcon"
  | "addTool"
  | "ammo"
  | "ammoStraightDefault"
  | "ammoStraightWood"
  | "ammoDiagonalDefault"
  | "ammoDiagonalWood"
  | "armor"
  | "food"
  | "gloves"
  | "helm"
  | "pants"
  | "roughGem"
  | "shapeLargeGem"
  | "shapeSmallGem"
  | "shield"
  | "shieldWooden"
  | "shoes"
  | "shoesMetal"
  | "siegeAmmo"
  | "siegeAmmoStraightDefault"
  | "siegeAmmoStraightWood"
  | "siegeAmmoDiagonalDefault"
  | "siegeAmmoDiagonalWood"
  | "tool"
  | "toolWood"
  | "toolStone"
  | "toolMetal"
  | "toolHiveBuilding"
  | "toolGlass"
  | "toolShape"
  | "toolGlassVariant"
  | "toolMetalVariant"
  | "toolStoneVariant"
  | "toolWoodVariant"
  | "toolMud"
  | "toolWater"
  | "toolVomit"
  | "toolBlood"
  | "toolDamage"
  | "toolBands"
  | "toolEngraving"
  | "toolStuds"
  | "toolRings"
  | "toolSpikes"
  | "toy"
  | "trapComponent"
  | "trapComponentWeaponTrap"
  | "trapComponentUpright1T"
  | "trapComponentUpright2T"
  | "trapComponentUpright3T"
  | "trapComponentUpright4T"
  | "trapComponentUpright5T"
  | "trapComponentUpright6T"
  | "trapComponentUpright7T"
  | "trapComponentUpright8T"
  | "trapComponentUpright9T"
  | "trapComponentUpright10T"
  | "trapComponentUpright1B"
  | "trapComponentUpright2B"
  | "trapComponentUpright3B"
  | "trapComponentUpright4B"
  | "trapComponentUpright5B"
  | "trapComponentUpright6B"
  | "trapComponentUpright7B"
  | "trapComponentUpright8B"
  | "trapComponentUpright9B"
  | "trapComponentUpright10B"
  | "weapon"
  | "weaponDefault"
  | "weaponWood"
  | "weaponWoodGrown"
  | "weaponMaterial"
  | "weaponTrap"
  | "weaponUpright1T"
  | "weaponUpright2T"
  | "weaponUpright3T"
  | "weaponUpright4T"
  | "weaponUpright5T"
  | "weaponUpright6T"
  | "weaponUpright7T"
  | "weaponUpright8T"
  | "weaponUpright9T"
  | "weaponUpright10T"
  | "weaponUpright1B"
  | "weaponUpright2B"
  | "weaponUpright3B"
  | "weaponUpright4B"
  | "weaponUpright5B"
  | "weaponUpright6B"
  | "weaponUpright7B"
  | "weaponUpright8B"
  | "weaponUpright9B"
  | "weaponUpright10B";
/**
 * A struct representing a sprite graphic.
 */
export type SpriteGraphic = {
  primaryCondition: Condition;
  tilePageId: string;
  offset: Dimensions;
  color: ColorModification | null;
  largeImage: boolean | null;
  offset2: Dimensions | null;
  secondaryCondition: Condition | null;
  colorPalletSwap: number | null;
  targetIdentifier: string | null;
  extraDescriptor: string | null;
};
/**
 * A struct representing a `SpriteLayer` object.
 */
export type SpriteLayer = {
  layerName: string;
  tilePageId: string;
  offset: Dimensions;
  offset2: Dimensions | null;
  largeImage: boolean | null;
  conditions: [Condition, string][] | null;
};
/**
 * A custom graphic extension.
 */
export type CustomGraphicExtension = {
  extensionType: GraphicType;
  tilePageId: string | null;
  value1: number | null;
  value2: number | null;
};
/**
 * A struct representing a Dimensions object.
 */
export type Dimensions = { x: number; y: number };
/**
 * A condition that can be applied to a tile/entity
 */
export type Condition =
  | "none"
  | "condition"
  | "default"
  | "animated"
  | "corpse"
  | "child"
  | "baby"
  | "trainedHunter"
  | "trainedWar"
  | "listIcon"
  | "skeleton"
  | "skeletonWithSkull"
  | "zombie"
  | "necromancer"
  | "male"
  | "female"
  | "vampireCursed"
  | "ghoul"
  | "disturbedDead"
  | "remains"
  | "vermin"
  | "lightVermin"
  | "hive"
  | "swarmSmall"
  | "swarmMedium"
  | "swarmLarge"
  | "notArtifact"
  | "craftedArtifact"
  | "dye"
  | "notDyed"
  | "crop"
  | "seed"
  | "picked"
  | "shrub"
  | "sapling"
  | "cropSprout"
  | "cropL"
  | "cropM"
  | "cropR"
  | "shrubDead"
  | "notChild"
  | "haulCountMin"
  | "haulCountMax"
  | "itemWorn"
  | "professionCategory"
  | "class"
  | "syndromeClass"
  | "caste"
  | "tissueLayer"
  | "materialFlag"
  | "materialType"
  | "shutOffIfItemPresent"
  | "randomPartIndex"
  | "ghost"
  | "tissueMayHaveColor"
  | "tissueMinLength"
  | "tissueMaxLength"
  | "tissueMinCurly"
  | "tissueMaxCurly"
  | "tissueMayHaveShaping"
  | "tissueNotShaped"
  | "tissueSwap"
  | "layer"
  | "layerSet"
  | "layerGroup"
  | "endLayerGroup"
  | "bodyUpper"
  | "copyOfTemplate"
  | "hammerman"
  | "masterHammerman"
  | "spearman"
  | "masterSpearman"
  | "wrestler"
  | "masterWrestler"
  | "axeman"
  | "masterAxeman"
  | "swordsman"
  | "masterSwordsman"
  | "maceman"
  | "masterMaceman"
  | "pikeman"
  | "masterPikeman"
  | "recruit"
  | "thief"
  | "masterThief"
  | "lasher"
  | "masterLasher"
  | "monsterSlayer"
  | "crossbowman"
  | "masterCrossbowman"
  | "bowman"
  | "masterBowman"
  | "blowgunman"
  | "masterBlowgunman"
  | "beastHunter"
  | "scout"
  | "ranger"
  | "hunter"
  | "sage"
  | "scholar"
  | "philosopher"
  | "mathematician"
  | "historian"
  | "astronomer"
  | "naturalist"
  | "chemist"
  | "geographer"
  | "scribe"
  | "bookbinder"
  | "performer"
  | "poet"
  | "bard"
  | "dancer";
/**
 * The color modification of the tile
 */
export type ColorModification = "asIs";
